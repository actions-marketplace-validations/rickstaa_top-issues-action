import dotenv from 'dotenv'

import {getInput} from '@actions/core'
import {context, getOctokit} from '@actions/github'
import {RequestError} from '@octokit/request-error'

dotenv.config()

const DASHBOARD_HEADER = `<!--- !!!DONT REMOVE OR CHANGE THIS HEADER. IT IS REQUIRED FOR THE ACTION TO FIND THE DASHBOARD!!!
This dashboard was generated by the [top-issues-action](https://github.com/rickstaa/top-issues-action) action.
-->

A simple dashboard that lists the top issues/bugs/features and pull requests.`
const DASHBOARD_FOOTER = `> Created by the [rickstaa/top-issues-action](https://github.com/rickstaa/top-issues-action) action (${new Date().toLocaleString()}).`

/**
 * Issue object returned by GraphQL.
 */
interface IssueNode {
  number: number
  title: string
  positive: {totalCount: number}
  negative: {totalCount: number}
  labels: {nodes: {name: string}[]}
}
/**
 * PR object returned by GraphQL.
 */
interface PRNode {
  number: number
  title: string
  positive: {totalCount: number}
  negative: {totalCount: number}
  labels: {nodes: {name: string}[]}
}

/**
 * Open issues object returned by GraphQL.
 */
interface OpenIssues {
  nodes: IssueNode[]
  pageInfo: {endCursor: string; hasNextPage: boolean}
}

/**
 * Open PRs object returned by GraphQL.
 */
interface OpenPRs {
  nodes: PRNode[]
  pageInfo: {endCursor: string; hasNextPage: boolean}
}

/**
 *  Issues response object returned by GraphQL.
 */
interface IssuesResponse {
  repository: {
    open_issues: OpenIssues
  }
}
interface PRsResponse {
  repository: {
    open_prs: OpenPRs
  }
}

/**
 * Repository info.
 */
interface RepoInfo {
  owner: string
  repo: string
}

type GithubContext = typeof context

/**
 * Fetch open issues from a repository.
 * @param user The user name of the repository owner.
 * @param repo The name of the repository.
 * @returns The open issues.
 */
const fetchOpenIssues = async (
  user: string,
  repo: string
): Promise<IssueNode[]> => {
  try {
    const {repository} = await octokit.graphql<IssuesResponse>(
      `
        {
          repository(owner: "${user}", name: "${repo}") {
            open_issues: issues(first: 100, states: OPEN) {
              nodes {
                number
                title
                positive: reactions(content: THUMBS_UP) {
                  totalCount
                }
                negative: reactions(content: THUMBS_DOWN) {
                  totalCount
                }
                labels(first: 10) {
                  nodes {
                    name
                  }
                }
                body
              }
              pageInfo {
                endCursor
                hasNextPage
              }
            }
          }
        }
      `
    )
    return repository.open_issues.nodes
  } catch (error) {
    if (error instanceof RequestError) {
      throw Error(
        `Could not retrieve top issues using GraphQl: ${error.message}.`
      )
    }
    throw error
  }
}

/**
 * Fetch open PRs from a repository.
 * @param user The user name of the repository owner.
 * @param repo The name of the repository.
 * @returns The open PRs.
 */
const fetchOpenPRs = async (user: string, repo: string): Promise<PRNode[]> => {
  try {
    const {repository} = await octokit.graphql<PRsResponse>(
      `
        {
          repository(owner: "${user}", name: "${repo}") {
            open_prs: pullRequests(first: 100, states: OPEN){
              nodes {
                number
                title
                positive: reactions(content: THUMBS_UP) {
                  totalCount
                }
                negative: reactions(content: THUMBS_DOWN) {
                  totalCount
                }
                labels(first: 10) {
                  nodes {
                    name
                  }
                }
              }
              pageInfo {
                endCursor
                hasNextPage
              }
            }
          }
        }
      `
    )
    return repository.open_prs.nodes
  } catch (error) {
    if (error instanceof RequestError) {
      throw Error(`Could not retrieve top PRs using GraphQl: ${error.message}.`)
    }
    throw error
  }
}

/**
 * Get the top issues.
 * @param issues Issues object to get the top issues from.
 * @param size Number of issues to get.
 * @returns Top issues.
 */
const getTopIssues = (issues: IssueNode[], size: number): IssueNode[] => {
  issues = issues.filter(issue =>
    SUBSTRACT_NEGATIVE
      ? issue.positive.totalCount - issue.negative.totalCount
      : issue.positive.totalCount > 0
  ) // Remove issues with no reactions
  issues = issues.sort((a: IssueNode, b: IssueNode) => {
    return SUBSTRACT_NEGATIVE
      ? b.positive.totalCount -
          b.negative.totalCount -
          (a.positive.totalCount - a.negative.totalCount)
      : b.positive.totalCount - a.positive.totalCount
  })
  return issues.slice(0, size)
}

/**
 * Retrieve issues that have the label.
 * @param issues The issues to check.
 * @param label The label to check for.
 */
const issuesWithLabel = (issues: IssueNode[], label: string): IssueNode[] => {
  return issues.filter((issue: IssueNode) => {
    return issue.labels.nodes.some(lab => lab.name === label)
  })
}

/**
 * Retrieve information about the repository that ran the action.
 * @param context Action context.
 * @returns Repository information.
 */
const getRepoInfo = (ctx: GithubContext): RepoInfo => {
  try {
    return {
      owner: ctx.repo.owner,
      repo: ctx.repo.repo
    }
  } catch (error) {
    return {
      owner: 'rickstaa',
      repo: 'top-issues-action'
    }
  }
}

// Create octokit client
const GITHUB_TOKEN: string | undefined = getInput('github_token')
  ? getInput('github_token')
  : process.env.GITHUB_TOKEN
if (!GITHUB_TOKEN) throw Error('Github token is missing.')
const octokit = getOctokit(GITHUB_TOKEN)

// Get action inputs
const TOP_LIST_SIZE: number = getInput('top_list_size')
  ? parseInt(getInput('top_list_size'))
  : 10
const SUBSTRACT_NEGATIVE: boolean = getInput('substract_negative')
  ? Boolean(getInput('substract_negative'))
  : true
const LABEL: boolean = getInput('label') ? Boolean(getInput('label')) : false
const DASHBOARD: boolean = getInput('dashboard')
  ? Boolean(getInput('dashboard'))
  : true
const HIDE_DASHBOARD_FOOTER: boolean = getInput('hide_acknowledgement_footer')
  ? Boolean(getInput('hide_acknowledgement_footer'))
  : false
const DASHBOARD_TITLE: string = getInput('dashboard_title')
  ? getInput('dashboard_title')
  : 'Top Issues Dashboard'
const DASHBOARD_LABEL: string = getInput('ashboard_label')
  ? getInput('dashboard_label')
  : ':star: top issues dashboard'
const DASHBOARD_LABEL_DESCRIPTION: string = getInput(
  'dashboard_label_description'
)
  ? getInput('dashboard_label_description')
  : 'Top issues dashboard.'
const DASHBOARD_LABEL_COLOUR: string = getInput('dashboard_label_colour')
  ? getInput('dashboard_label_colour')
  : '#EED801'

const TOP_ISSUES: boolean = getInput('top_issues')
  ? Boolean('top_issues')
  : true
const TOP_ISSUE_LABEL: string = getInput('top_issue_label')
  ? getInput('top_issue_label')
  : ':star: top issue'
const TOP_ISSUE_LABEL_DESCRIPTION: string = getInput(
  'top_issue_label_description'
)
  ? getInput('top_issue_label_description')
  : 'Top issue.'
const TOP_ISSUE_LABEL_COLOUR: string = getInput('top_issue_label_colour')
  ? getInput('top_issue_label_colour')
  : '#027E9D'

const TOP_BUGS: boolean = getInput('top_bugs') ? Boolean('top_bugs') : true
const BUG_LABEL: string = getInput('bug_label') ? getInput('bug_label') : 'bug'
const TOP_BUG_LABEL: string = getInput('top_bug_label')
  ? getInput('top_bug_label')
  : ':star: top bug'
const TOP_BUG_LABEL_TEXT: string = getInput('top_bug_label_text')
  ? getInput('top_bug_label_text')
  : 'Top bug.'
const TOP_BUG_LABEL_COLOUR: string = getInput('top_bug_label_colour')
  ? getInput('top_bug_label_colour')
  : '#B60205'

const TOP_FEATURES: boolean = getInput('top_features')
  ? Boolean('top_features')
  : true
const FEATURE_LABEL: string = getInput('feature_label')
  ? getInput('feature_label')
  : 'enhancement'
const TOP_FEATURE_LABEL: string = getInput('top_feature_label')
  ? getInput('top_feature_label')
  : ':star: top feature'
const TOP_FEATURE_LABEL_TEXT: string = getInput('top_feature_label_text')
  ? getInput('top_feature_label_text')
  : 'Top feature request.'
const TOP_FEATURE_LABEL_COLOUR: string = getInput('top_feature_label_colour')
  ? getInput('top_feature_label_colour')
  : '#0E8A16'

const TOP_PULL_REQUEST: boolean = getInput('top_pull_requests')
  ? Boolean('top_pull_requests')
  : true
const TOP_PULL_REQUEST_LABEL: string = getInput('top_pull_request_label')
  ? getInput('top_pull_request_label')
  : ':star: top pull request'
const TOP_PULL_REQUEST_LABEL_TEXT: string = getInput(
  'top_pull_request_label_text'
)
  ? getInput('top_pull_request_label_text')
  : 'Top pull request.'
const TOP_PULL_REQUEST_LABEL_COLOUR: string = getInput(
  'top_pull_request_label_colour'
)
  ? getInput('top_pull_request_label_colour')
  : '#41A285'

/**
 * Add a label to a list of issues.
 * @param owner The owner of the repository.
 * @param repo The name of the repository.
 * @param issues The issues to add the label to.
 * @param label The label to add.
 * @returns
 */
const labelIssues = (
  owner: string,
  repo: string,
  issues: IssueNode[],
  label: string
): void => {
  for (const issue of issues) {
    addLabelToIssue(owner, repo, issue, label)
  }
}

/**
 * Rove a label from a list of issues.
 * @param owner The owner of the repository.
 * @param repo The name of the repository.
 * @param issues The issues to add the label to.
 * @param label The label to add.
 * @returns
 */
const removeLabelFromIssues = (
  owner: string,
  repo: string,
  issues: IssueNode[],
  label: string
): void => {
  for (const issue of issues) {
    removeLabelFromIssue(owner, repo, issue, label)
  }
}

/**
 * Add a label to an issue.
 * @param owner The owner of the repository.
 * @param repo The name of the repository.
 * @param issue The issue to add the label to.
 * @param label The label to add.
 * @returns
 */
const addLabelToIssue = (
  owner: string,
  repo: string,
  issue: IssueNode,
  label: string
): void => {
  if (!issue.labels.nodes.some(lab => lab.name === label)) {
    octokit.rest.issues.addLabels({
      owner,
      repo,
      issue_number: issue.number,
      labels: [label]
    })
  }
}

/**
 * Remove a label from an issue.
 * @param owner The owner of the repository.
 * @param repo The name of the repository.
 * @param issue The issue to add the label to.
 * @param label The label to add.
 * @returns
 */
const removeLabelFromIssue = (
  owner: string,
  repo: string,
  issue: IssueNode,
  label: string
): void => {
  if (issue.labels.nodes.some(lab => lab.name === label)) {
    octokit.rest.issues.removeLabel({
      owner,
      repo,
      issue_number: issue.number,
      name: label
    })
  }
}

/**
 * Get the difference between to lists of issues.
 * @param issuesOne First list of issues.
 * @param issuesTwo Second list of issues.
 * @returns The difference between the two lists.
 */
const getIssuesDifference = (
  issuesOne: IssueNode[],
  issuesTwo: IssueNode[]
): IssueNode[] => {
  return issuesOne.filter(
    ({number: id1}) => !issuesTwo.some(({number: id2}) => id2 === id1)
  )
}

/**
 * Make sure that a label exists with the correct colour and description.
 * @param owner The owner of the repository.
 * @param repo The name of the repository.
 * @param label The label to check.
 * @param labelDescription The description of the label.
 * @param labelColour The colour of the label.
 */
const initLabel = async (
  owner: string,
  repo: string,
  label: string,
  labelDescription: string,
  labelColour: string
): Promise<void> => {
  const topIssueLabelColourBare = labelColour.replace('#', '')

  return new Promise(async (resolve, reject) => {
    try {
      const currentLabels = await octokit.rest.issues.listLabelsForRepo({
        owner,
        repo
      })
      const currentLabel = currentLabels.data.find(
        ({name: labelName}) => labelName === label
      )

      // Create label if it doesn't exist and update it if it does.
      if (!currentLabel) {
        await octokit.rest.issues.createLabel({
          owner,
          repo,
          name: label,
          color: topIssueLabelColourBare,
          description: labelDescription
        })
      } else {
        if (
          currentLabel.description !== labelDescription ||
          currentLabel.color !== topIssueLabelColourBare
        ) {
          await octokit.rest.issues.updateLabel({
            owner,
            repo,
            name: label,
            color: labelColour,
            description: labelDescription
          })
        }
      }
      resolve()
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Label the top issues.
 * @param owner Repository owner.
 * @param repo Repository name.
 * @param currentTopIssues Current top issues.
 * @param newTopIssues New top issues.
 * @param topIssueLabel Label to add to the top issues.
 * @param topIssueLabelDescription Description of the top issues label.
 * @param topIssueLabelColour Colour of the top issues label.
 */
const labelTopIssues = async (
  owner: string,
  repo: string,
  currentTopIssues: IssueNode[],
  newTopIssues: IssueNode[],
  topIssueLabel: string,
  topIssueLabelDescription: string,
  topIssueLabelColour: string
): Promise<void> => {
  await initLabel(
    owner,
    repo,
    topIssueLabel,
    topIssueLabelColour,
    topIssueLabelDescription
  )
  labelIssues(owner, repo, newTopIssues, topIssueLabel)
  const topIssuesToPrune = getIssuesDifference(currentTopIssues, newTopIssues)
  removeLabelFromIssues(owner, repo, topIssuesToPrune, topIssueLabel)
}

/**
 * Main function.
 */
async function run(): Promise<void> {
  const {owner, repo} = getRepoInfo(context)
  const issues = await fetchOpenIssues(owner, repo)
  const PRs = await fetchOpenPRs(owner, repo)

  // Give warning if nothing to do.
  if ((!TOP_ISSUES && !TOP_BUGS && !TOP_FEATURES) || (!LABEL && !DASHBOARD)) {
    console.log('Nothing to do 💤.') // Replace with action log.
    return
  }

  // Retrieve and label top issues
  let newTopIssues: IssueNode[] = []
  if (TOP_ISSUES) {
    const currentTopIssues = issuesWithLabel(issues, TOP_ISSUE_LABEL)
    newTopIssues = getTopIssues(issues, TOP_LIST_SIZE)
    if (LABEL) {
      await labelTopIssues(
        owner,
        repo,
        currentTopIssues,
        newTopIssues,
        TOP_ISSUE_LABEL,
        TOP_ISSUE_LABEL_DESCRIPTION,
        TOP_ISSUE_LABEL_COLOUR
      )
    }
  }

  // Retrieve and label top bugs
  let newTopBugs: IssueNode[] = []
  if (TOP_BUGS) {
    const bugIssues = issuesWithLabel(issues, BUG_LABEL)
    const currentTopBugs = issuesWithLabel(issues, TOP_BUG_LABEL)
    newTopBugs = getTopIssues(bugIssues, TOP_LIST_SIZE)
    if (LABEL) {
      await labelTopIssues(
        owner,
        repo,
        currentTopBugs,
        newTopBugs,
        TOP_BUG_LABEL,
        TOP_BUG_LABEL_TEXT,
        TOP_BUG_LABEL_COLOUR
      )
    }
  }

  // Retrieve and label top features
  let newTopFeatures: IssueNode[] = []
  if (TOP_FEATURES) {
    const featureIssues = issuesWithLabel(issues, FEATURE_LABEL)
    const currentTopFeatures = issuesWithLabel(issues, TOP_FEATURE_LABEL)
    newTopFeatures = getTopIssues(featureIssues, TOP_LIST_SIZE)
    if (LABEL) {
      await labelTopIssues(
        owner,
        repo,
        currentTopFeatures,
        newTopFeatures,
        TOP_FEATURE_LABEL,
        TOP_FEATURE_LABEL_TEXT,
        TOP_FEATURE_LABEL_COLOUR
      )
    }
  }

  // Retrieve and label top PRs
  let newTopPRs: IssueNode[] = []
  if (TOP_PULL_REQUEST) {
    const currentTopPRs = issuesWithLabel(PRs, TOP_PULL_REQUEST_LABEL)
    newTopPRs = getTopIssues(PRs, TOP_LIST_SIZE)
    if (LABEL) {
      await labelTopIssues(
        owner,
        repo,
        currentTopPRs,
        newTopPRs,
        TOP_PULL_REQUEST_LABEL,
        TOP_PULL_REQUEST_LABEL_TEXT,
        TOP_PULL_REQUEST_LABEL_COLOUR
      )
    }
  }

  // Create top issues dashboard
  if (DASHBOARD) {
    let dashboard_body = `${DASHBOARD_HEADER}`
    if (newTopIssues.length > 0) {
      dashboard_body += `\n\n## Top issues\n`
      dashboard_body += `\n${newTopIssues
        .map((issue, idx) => `${idx + 1}. #${issue.number}`)
        .join('\n')}`
    }
    if (newTopBugs.length > 0) {
      dashboard_body += `\n\n## Top bugs\n`
      dashboard_body += `\n${newTopBugs
        .map((bug, idx) => `${idx + 1}. #${bug.number}`)
        .join('\n')}`
    }
    if (newTopFeatures.length > 0) {
      dashboard_body += `\n\n## Top features\n`
      dashboard_body += `\n${newTopFeatures
        .map((feature, idx) => `${idx + 1}. #${feature.number}`)
        .join('\n')}`
    }
    if (newTopPRs.length > 0) {
      dashboard_body += `\n\n## Top PRs\n`
      dashboard_body += `\n${newTopPRs
        .map((PR, idx) => `${idx + 1}. #${PR.number}`)
        .join('\n')}`
    }
    // TODO: Add creation time.
    if (!HIDE_DASHBOARD_FOOTER) {
      dashboard_body += `\n\n${DASHBOARD_FOOTER}`
    }

    // Create new issue with dashboard body
    initLabel(
      owner,
      repo,
      DASHBOARD_LABEL,
      DASHBOARD_LABEL_COLOUR,
      DASHBOARD_LABEL_DESCRIPTION
    )
    let dashboardIssue = issuesWithLabel(issues, DASHBOARD_LABEL)
    if (dashboardIssue.length === 0) {
      dashboardIssue = issues.filter(issue => issue.title === DASHBOARD_TITLE)
    }
    if (dashboardIssue.length > 0) {
      octokit.rest.issues.update({
        owner,
        repo,
        issue_number: dashboardIssue[0].number,
        title: DASHBOARD_TITLE,
        body: dashboard_body
      })
    } else {
      octokit.rest.issues.create({
        owner,
        repo,
        title: DASHBOARD_TITLE,
        body: dashboard_body
      })
    }
  }
}

run()
